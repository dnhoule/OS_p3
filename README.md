## Unix Shell

In this project, I built a Unix Shell that handles the same basic functionalities as Bash using C. 


### Specs

The shell is very simple (conceptually): it runs in a while loop, repeatedly asking for input to tell it what command to execute. It then executes that command. The loop continues indefinitely, until the user types the built-in command `exit`, at which point it exits. That’s it!

For reading lines of input, I used `getline()`. This allows you to obtain arbitrarily long input lines with ease. Generally, the shell will be run in *interactive mode*, where the user types a command (one at a time) and the shell acts on it. However, the shell will also support *batch mode*, in which the shell is given an input file of commands; in this case, the shell should not read user input (from `stdin`) but rather from this file to get the commands to execute.

In either mode, if you hit the end-of-file marker (EOF), I should call `exit(0)` and exit gracefully. EOF can be generated by pressing `Ctrl-D`.

To parse the input line into constituent pieces, you might want to use `strsep()`. Read the man page (carefully) for more details.

To execute commands, I used `fork()`, `exec()`, and `wait()/waitpid()`. See the man pages for these functions.

You will note that there are a variety of commands in the `exec` family; for this project, I used `execvp`.

### Paths

In our example above, the user typed `ls` but the shell knew to execute the program `/bin/ls`. How does your shell know this?

It turns out that the user must specify a **path** variable to describe the set of directories to search for executables; the set of directories that comprise the path are sometimes called the search path of the shell. The path variable contains the list of all directories to search, in order, when the user types a command.

**Important:** Note that the shell itself does not implement `ls` or other commands (except built-ins). All it does is find those executables in one of the directories specified by path and create a new process to run them.

To check if a particular file exists in a directory and is executable, consider the `access()` system call. For example, when the user types `ls`, and path is set to include both `/usr/bin` and `/bin` (assuming empty path list at first, `/bin` is added, then `/usr/bin` is added), try `access("/usr/bin/ls", X_OK)`. If that fails, try `/bin/ls`. If that fails too, it is an error.

The initial shell path should contain one directory: `/bin`

Note: Most shells allow you to specify a binary specifically without using a search path, using either **absolute paths** or **relative paths**. For example, a user could type the absolute path `/bin/ls` and execute the `ls` binary without a search path being needed. A user could also specify a relative path which starts with the current working directory and specifies the executable directly, e.g., `./main`. In this project, I do not handle this feature.

### Built-in Commands

Whenever the shell accepts a command, it should check whether the command is a **built-in command** or not. If it is, it should not be executed like other programs. Instead, the shell will invoke your implementation of the built-in command. 

In this project, I implement `exit`, `cd`, `jobs`, `fg` and `bg` as built-in commands.

* `exit`: When the user types exit, the shell should simply call the `exit` system call with 0 as a parameter. It is an error to pass any arguments to `exit`.

* `cd`: `cd` always take one argument (0 or >1 args should be signaled as an error). To change directories, use the `chdir()` system call with the argument supplied by the user; if `chdir` fails, that is also an error.

* `jobs`: `jobs` command prints jobs in the background in the following format `<id>: <program name> <arg1> <arg2> … <argN> [&]`. `<id>` is an index number for the command that was run in the background. If the command was initiated as a background job (as explained below), an ampersand (`&`) is appended after `<argN>`. In cases where the command line includes a pipe (as detailed below), the format should be `<id>: <program 1 name> <arg1> … <argN> | <program 2 name> <arg1> … <argN> | … [&]`. 

* `fg` and `bg`: `fg` and `bg` commands are used for moving processes into foreground/background. This operation changes association with the controlling terminal. These commands can be run with 0 or 1 argument. If the argument is specified, it is the `<id>` of the job to be moved to foreground/background. If there is no argument, the largest job `<id>` is used. 

* For each new job, the job `<id>` for it should be the smallest positive integer not in use. For instance, if `1`, `2` and `4` are used for job `<id>`s, `<id>` for the next job is `3`. 

### Controlling Terminal

`Ctrl-C` sends a `SIGINT` and `Ctrl-Z` sends a `SIGTSTP` signal. The terminal is a controlling terminal for those processes receiving signals. When a process runs in the background, it should not receive these signals. The signals can also be sent with `kill` or `pkill`.

Note that with terminal job control support, you need to properly set foreground process group always, when the foreground process is changed.

### Background Job

The shell will also allow the user to launch background commands. This is accomplished with the ampersand operator as follows:

```sh
wsh> <cmd> <args…> &
```

In this case, instead of running `cmd` and then waiting for it to finish, the shell should run `cmd` in the background and allow the user to run another command.

### Pipes

Pipe is one of the basic UNIX concepts and the shell supports it. It allows composition of multiple simple programs together to create a command with a complex behavior. This is so powerful that it is basically ubiquitous in shell scripts because you can express very complex behavior with very few lines of code. Pipe, denoted as `|`, redirects standard output of the program on the left side to the input of the program on the right side.

```sh
<program1> <arglist1> | <program2> <arglist2> | ... | <programN> <arglistN> [&]
```

The example below shows a command, which compresses a file `f.txt`, decompress it and prints the last 10 lines of the decompressed file.

```sh
cat f.txt | gzip -c | gunzip -c | tail -n 10
```

-1.  Non-error conditions should result in an exit code of 0.

